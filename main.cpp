#include <sys/wait.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <vector>
#include <fstream>
#include <sstream>
#include <readline/readline.h>
#include <readline/history.h>


using namespace std;

char** args;
string currentDirectory = get_current_dir_name();
char username[32];

//Vector to hold build in functions
vector<string> builtins = {
    "cd",
    "clear",
    "lukescript"
};

//Helper function to see if a command is a built in function
bool isBuiltIn(string command){
    for(auto elem : builtins){
        if(elem == command){return true;}
    }
    return false;
}


//Helper function to execute the given arguments
void shlLaunch(char** args){
    pid_t pid;
    int status;

    //Fork the process
    //If the pid is less than 0, exit with an error
    if((pid = fork()) < 0){exit(1);}
    //If the pid is 0, this is the child process, and it can execute the arguments
    else if(pid == 0){
        if(execvp(args[0], args) < 0){
            perror("shl");
            exit(1);
        }
    }
    //If the pid isn't 0, then this is the parent process, and it needs to wait for the child to finish
    else{
        if((pid = wait(&status)) == -1){perror("shl");}
    }
}


//Helper function to take a string input and arrange it into a char**
void tokenize(string input){
    vector<string> words;
    string currWord = "";
    //Loop through every char in the input
    for(auto letter : input){
        //If there is a space, add the current word to the words list
        if(letter == ' '){words.push_back(currWord); currWord = "";}
        //This stops at 15 because splitting the arguments into multiple sections is easier than reallocating the char* to whatever size the argument is
        else if(currWord.length() == 15){words.push_back(currWord); currWord = string(1, letter);}
        else{currWord += letter;}
    }
    //The last word might not have a space after it, so it needs to be added here
    words.push_back(currWord);

    //Set args equal to a new char** with the size of the words vector plus one
    args = new char*[words.size() + 1];
    
    //Fill args with the list of arguments
    for(int i = 0; i < words.size(); i++){
        args[i] = &words[i][0];
    }
    
    //The last item in the args list needs to be NULL
    args[words.size()] = NULL;

}

//Helper function to execute build in functions
void executeBuiltIns(string builtin, string input = ""){
    if(builtin == "cd"){
        if(args[1] == NULL){
            fprintf(stderr, "shl: Expected path. \n");
        }
        else{
            //Set the current directory to the path specified
            if(chdir(args[1]) != 0){
                perror("shl");
            }
            //Change the currentDirectory variable
            currentDirectory = get_current_dir_name();
        }
    }
    if(builtin == "clear"){
        //Clear the terminal
        system("clear");
    }
    if(builtin == "lukescript"){

        //See if there is a file being specified
        if(strcmp(args[1], "-f") == 0){
            
            string pathstr = "";
            int i = 2;
            //The path can be stored in more than one index of args (since the limit was 15 characters) so they all need to be added to the path string
            while(args[i] != NULL){
                pathstr += args[i];
                i++;
            }

            //Open the file specified 
            ifstream file(pathstr, std::ios::in);
            //Test if the file exists
            if(!file.good()){perror("shl"); return;}
            //Read the file into a stringstream
            stringstream ss;
            ss << file.rdbuf();
            
            //Change the input to hold the script in the file
            input = "lukescript " + ss.str(); 
            file.close();
        }

        //Open the text file where lukescript executes programs from
        ofstream file("./rundata/lukescript.txt", std::ios::out | std::ios::trunc);
        //The input starts with 'lukescript', so that needs to be cut out before the input is added to the file
        file << input.substr(10);
        file.close();

        //Path to the shell executable 
        string shellpath = "./bin/Debug/net5.0/shell";

        //Use the shlLaunch function to start lukescript
        char* tempArgs[] = {&shellpath[0], NULL};

        shlLaunch(tempArgs);

        //Open the commands file
        ifstream file2("./rundata/lukescriptcommands.txt");
        string commands;
        stringstream SS;
        SS << file2.rdbuf();
        commands = SS.str();
        commands = commands.substr(0, commands.length() - 1);

        //If there are any commands generated by Lukescript, execute them
        if(commands.size() > 0){
            tokenize(commands);
            shlLaunch(args);
        }
    }


}



int main(){
    //Get the current username
    cuserid(username);
    const char* userInput;
    //Get the user input
    userInput = readline(("[\001\e[1;36m\002" + string(username) + "\001\e[1;0m\002] [\001\e[1;32m\002" + currentDirectory + "\001\e[1;0m\002]>").c_str());
    //Run while the input does not equal 'exit'
    while(strcmp(userInput, "exit") != 0){
        //Add history to the readline library
        if(*userInput) add_history(userInput);
        
        //Arrange user input into a char**
        tokenize(userInput);

        //Execute built ins
        if(isBuiltIn(args[0])){
            executeBuiltIns(args[0], userInput);
        }
        //Execute commands
        else{
            shlLaunch(args);
        }

        userInput = readline(("[\001\e[1;36m\002" + string(username) + "\001\e[1;0m\002] [\001\e[1;32m\002" + currentDirectory + "\001\e[1;0m\002]>").c_str());
        //Free args
        delete []args;
    }

    return 0;
}
